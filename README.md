# TinyHouse

Версия 1.0.0

[Демо](https://tinyhouseapp.herokuapp.com/)

Хостинг реализован с использованием облачной PaaS-платформы (англ. platform as a service - "платформа как сервис") [Heroku](https://herokuapp.com/). Дождитесь загрузки приложения.

## Описание

TinyHouse - это онлайн-площадка для размещения и поиска краткосрочной аренды частного жилья.

Данный проект реализован в рамках учебного курса [TinyHouse: A Fullstack React Masterclass with TypeScript and GraphQL](https://www.newline.co/tinyhouse) на платформе [newline](https://www.newline.co/) для приобретения навыка создания современных веб-приложений с использованием таких наиболее популярных технологий, как [React](https://reactjs.org/), [GraphQL](https://graphql.org/), [Node.js](https://nodejs.org/), [MongoDB](https://www.mongodb.com/) и [TypeScript](https://www.typescriptlang.org/).

При создании приложения использован подход, основанный на API. Разработан GraphQL API, представляющий собой интерфейс, который содержит бизнес-логику и предоставляет данные с сервера. Клиент, т.е. веб-приложение, взаимодействует с этим API для получения и сохранения данных. Такая модель разработки, основанная на API, помогает разделить код бэкенда (англ. back-end) и фронтенда (англ. front-end), что расширяет возможности создания нескольких фронтенд-клиентов для взаимодействия с одним и тем же API.

## Используемые технологии

HTML, CSS, JavaScript (ES6+), React, React Hooks, React Router, GraphQL, Apollo, Node.js, Express, MongoDB, TypeScript, Ant Design, Stripe, Git, Webpack

### Сервер

Сервер создан для обслуживания [GraphQL](https://graphql.org/) API и обработки API-запросов с целью получения и изменения данных из базы данных [MongoDB](https://www.mongodb.com/). Надежный, хорошо документированный и готовый к продакшену GraphQL API построен с помощью платформы [Apollo](https://www.apollographql.com/). Разработка сервера осуществлена при помощи программной платформы [Node.js](https://nodejs.org/) для выполнения JavaScript-кода и веб-фреймворка маршрутизации и промежуточной обработки [Express](http://expressjs.com/) для приложений Node.js. MongoDB-кластер и управляемая база данных созданы с помощью [MongoDB Atlas](https://www.mongodb.com/cloud/atlas), глобального облачного сервиса баз данных для приложений. Подключение к базе данных MongoDB для работы с данными осуществляется посредством официального [MongoDB Node Driver](https://docs.mongodb.com/drivers/node/current/). Аутентификация осуществляется при помощи [Google Sign-In (и OAuth 2.0)](https://developers.google.com/identity/sign-in/web/backend-auth). Обработка онлайн-платежей выполняется с помощью [Stripe](https://stripe.com/). Запросы поиска, основанные на местоположении, обрабатываются при помощи [Google's Geocode](https://developers.google.com/maps/documentation/geocoding/overview). Загруженные пользователями изображения сохраняются при помощи [Cloudinary](https://cloudinary.com/). Сервер развернут с помощью [Heroku](https://herokuapp.com/). Статическую типизацию обеспечивает [TypeScript](https://www.typescriptlang.org/).

### Клиент

Динамический UI создан с использованием [React](https://reactjs.org/). Для управления логикой компонентов применяются [React Hooks](https://reactjs.org/docs/hooks-intro.html). Для выполнения запросов к GraphQL API, кэширования данных, полученных с сервера, и обновления UI используется [Apollo Client](https://www.apollographql.com/apollo-client). Маршрутизация на стороне клиента настроена с помощью [React Router](https://reactrouter.com/). Представительные и красивые React-компоненты построены с помощью популярного React UI-фреймворка [Ant Design](https://ant.design/). Как и на сервере, для создания надежного веб-приложения со статической типизацией используется [TypeScript](https://www.typescriptlang.org/).

## Краткое описание технологий

### TypeScript

[TypeScript](https://www.typescriptlang.org/) - язык программирования, который не использует интерпретатор и не проводит компиляцию кода в низкоуровневый язык, а вместо этого компилирует программу в другой высокоуровневый язык - JavaScript.

TypeScript позиционируется как средство разработки веб-приложений, расширяющее возможности JavaScript. TypeScript привносит в JavaScript статичную систему типов, которая моделирует процесс выполнения JavaScript-кода: позволяет найти код, который выдаст исключение при выполнении, без его запуска.

Преимущества использования TypeScript:

- делает код более простым для чтения и понимания;
- позволяет избежать болезненных багов, с которыми сталкиваются разработчики при написании кода на JavaScript;
- в конечном итоге экономит время и силы разработчиков.

В данном проекте TypeScript интегрирован как на клиенте, так и на сервере.

### Node

[Node](https://nodejs.org/) - программная платформа, основанная на движке [V8](<https://en.wikipedia.org/wiki/V8_(JavaScript_engine)>), транслирующем JavaScript в машинный код, которая превращает JavaScript из узкоспециализированного языка в язык общего назначения. Node добавляет возможность JavaScript взаимодействовать с устройствами ввода-вывода через свой API, написанный на C++, подключать другие внешние библиотеки, написанные на разных языках, обеспечивая вызовы к ним из JavaScript-кода. Node применяется преимущественно на сервере, выполняя роль веб-сервера.

Программирование сервера во многом сводится к решению типовых задач. В таких ситуациях помогают фреймворки - наборы стандартных решений. В данном проекте для разработки серверного кода используется популярный фреймворк маршрутизации и промежуточной обработки [Express](http://expressjs.com/), который позволяет разворачивать сервер быстрее и лучше понимать код других разработчиков.

### GraphQL

[GraphQL](https://graphql.org/) - это язык запросов с открытым исходным кодом, который создавался как более эффективная альтернатива [REST](https://ru.wikipedia.org/wiki/REST) для разработки и использования программных интерфейсов приложений. Помимо этого GraphQL является ещё и средой выполнения запросов клиента.

GraphQL обладает множеством достоинств:

- _Интуитивный_. Вместо работы с жёстко определенными на сервере конечными точками (англ. endpoints), как в случае с традиционным REST API, позволяет с помощью одного запроса получить информацию именно в том объёме, в котором её запрашивает клиент, что делает код интуитивным и более понятным.
- _Производительный_. Отсутствие необходимости передавать ненужные данные уменьшает задержку и повышает скорость работы приложения, что особенно важно для медленного интернет-соединения.
- _Типизированный_. GraphQL является сильно типизированным языком, который использует систему типов для предварительной оценки корректности запроса. Это прекрасно интегрируется с TypeScript для создания надежного статически типизированного приложения.

GraphQL API также:

- самодокументируемый;
- удобно использовать с [GraphQL Playground](https://github.com/graphql/graphql-playground), браузерной IDE (англ. Integrated Development Environment - "интегрированная среда разработки"), для исследования GraphQL API;
- состоит всего из одной конечной точки (англ. endpoint).

Возможности GraphQL Playground:

- просмотр документации по схеме GraphQL;
- выполнение запросов на получение и изменение данных, чтобы убедиться, что API работает должным образом, без использования такого инструмента, как [Postman](https://www.postman.com/);
- просмотр истории запросов;
- автоматическая перезагрузка схемы GraphQL;
- настройка HTTP-заголовков;
- и др.

GraphQL не привязан к какой-либо конкретной технологии, т.к. является [спецификацией](https://github.com/graphql/graphql-spec) для клиент-серверного взаимодействия, а не прямой реализацией. Спецификация описывает язык и грамматику, которые необходимо применять при написании запросов. Она также устанавливает систему типов, механизмы её выполнения и проверки. Сообщество создало серверные реализации и клиентские библиотеки для создания и использования GraphQL API для множества различных технологий. В данном проекте применяется серверная библиотека [Apollo Server](https://github.com/apollographql/apollo-server) и клиентская библиотека [Apollo Client](https://github.com/apollographql/apollo-client).

### MongoDB

[MongoDB](https://www.mongodb.com/) - это документоориентированная система управления базами данных, не требующая описания схемы таблиц. Считается одним из классических примеров [NoSQL](https://ru.wikipedia.org/wiki/NoSQL)-систем, использует [JSON](https://ru.wikipedia.org/wiki/JSON)-подобные документы и схему базы данных. MongoDB можно интегрировать в приложение, установив её локально на компьютер или воспользовавшись платформой DBaaS (англ. Database-as-a-Service - "база данных как сервис").

Некоторые из преимуществ использования DBaaS:

- Обслуживание и управление инфраструктурой базы данных становится обязанностью поставщика услуг.
- Система безопасности доступна прямо "из коробки".
- Масштабируемость и более высокая доступность. По мере роста приложения можно переконфигурировать облачную базу данных с большей вычислительной мощностью.

В данном проекте в качестве DBaaS используется облачный сервис [MongoDB Atlas](https://www.mongodb.com/cloud/atlas), который упрощает управление и размещение данных в облаке с помощью кластеров. [Кластер MongoDB](https://www.mongodb.com/basics/clusters) - это, по сути, группа их двух и более серверов, которые работают вместе, чтобы предоставить пользователям более высокую доступность, масштабируемость и надёжность.

Существует несколько различных библиотек и инструментов, которые можно использовать для подключения и взаимодействия с базой данных MongoDB из серверного приложения Node. В данном проекте для подключения использован официальный драйвер [MongoDB Node Driver](https://docs.mongodb.com/drivers/node/current/). MongoDB Node Driver обеспечивает взаимодействие с MongoDB как на основе колбэков (англ. callbacks) (функций обратного вызова), так и на основе промисов (англ. promises).

### React

В традиционных приложениях, написанных на HTML и JavaScript, для динамического обновления интерфейса используется классический (императивный) подход: разрабочик описывает последовательности изменений на HTML-странице при наступлении каких-либо событий. В этом случае JavaScript используется для непосредственного управления [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) (англ. Document Object Model - "объектная модель документа"). Когда приложение разрастается, становится много кода, ответственного за ручное изменение DOM, в котором легко ошибиться.

_Virtual DOM_

[React](https://reactjs.org/) изменил парадигму внесения изменений в UI с помощью [Virtual DOM](https://reactjs.org/docs/faq-internals.html) (англ. Virtual Document Object Model - "виртуальная объектная модель документа"), сделав подход декларативным: разработчику достаточно описать, как части интерфейса приложения выглядят в разных состояниях, а ответственность за своевременное их обновление при изменении данных React берёт на себя. Это абстрагирует манипуляции с атрибутами, обработку событий и ручное обновление DOM, а также позволяет стандартизировать код, придерживаясь единых способов решения типовых задач, что в конечном итоге повышает гибкость и надёжность в больших проектах.

Виртуальный DOM - это, по сути, просто дерево JavaScript-объектов, которое представляет структуру реального DOM. При каких-либо изменениях в React-приложении создаётся обновленный виртуальный DOM, который затем сравнивается с последним сохранённым виртуальным DOM, после чего React определяёт минимальное необходимое количество изменений и вносит их в реальный DOM.

Процесс, при котором виртуальное представление UI синхронизируется с реальным DOM, называется [согласованием](https://reactjs.org/docs/reconciliation.html). Необходимость применения такого алгоритма обусловлена тем, что намного быстрее сравнить два сложных JavaScript-объекта, чем произвести аналогичные операции над реальным DOM. В результате, React-приложения с большим количеством меняющихся данных обладают высокой скоростью работы.

_JSX_

React даёт разработчику возможность использовать [JSX](https://reactjs.org/docs/glossary.html#jsx), расширение языка JavaScript. JSX - это специальный синтаксис, который обладает всей мощью JavaScript, помогает создавать разметку в JavaScript и упрощает описания структуры.

В React логика рендеринга неразрывно связана с прочей логикой UI. Вместо того, чтобы искусственно разделить технологии, помещая разметку и логику в разные файлы, React разделяет ответственность с помощью слабо связанных единиц, называемых «компонентами», которые содержат и разметку, и логику. После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого - объект JavaScript.

JSX предотвращает атаки, основанные на инъекции кода. Данные, введённые пользователем, можно безопасно использовать в JSX. По умолчанию React DOM экранирует все значения, включённые в JSX, перед тем как отрендерить их. Это гарантирует, что никогда не будет внедрено что-либо, что не было явно написано в приложении. Всё преобразуется в строки, перед тем как быть отрендерённым. Это помогает предотвращать атаки [межсайтовым скриптингом (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting).

_Переиспользуемые компоненты_

[Компоненты](https://reactjs.org/docs/glossary.html#components) - это основные строительные блоки React-приложения, которые предоставляют возможность разбить его логику на небольшие независимые части. Их можно комбинировать и переиспользовать, что является одним из значительных преимуществ больших хорошо струтурированных приложений.

Компоненты во многом ведут себя как обычные JavaScript-функции. Они принимают произвольные входные данные (так называемые «пропсы») и возвращают React-элементы, описывающие, что мы хотим увидеть на экране.

_Приложения, управляемые данными_

Состояние - это модель данных. Компоненты можно показывать или прятать в зависимости от текущего состояния. Для этого разработчик объясняет React, как состояние влияет на то, какие компоненты требуется скрыть, а какие - отрендерить, и как именно. Состояние доступно только для самого компонента и скрыто от других.

_Пропсы и однонаправленный поток данных_

Компонент может передать своё состояние вниз по дереву в виде пропсов (англ. props, сокращение от properties - "свойства") дочерних компонентов. Этот процесс называется «нисходящим» (англ. «top-down») или «однонаправленным» (англ. «unidirectional») потоком данных. Когда происходит изменение состояния компонента, React вызывает его повторный рендеринг, а также всех компонентов-потомков, зависящих от любых производных этого состояния. Благодаря такому способу передачи данных от родителя к потомку, код работает быстро, но остаётся понятным.

_Классы и функциональные компоненты_

React дает разработчику возможность создавать компоненты одним из двух способов: с помощью классов или функций. В любом случае ожидается, что будет возвращён React-элемент.

Традиционно классовые компоненты должны были использоваться для объявления состояния и применения методов жизненного цикла компонента, в которые чаще всего входило описание "побочных эффектов" (англ. side effects): загрузка данных, оформление подписки и изменение DOM вручную. В связи с этим часто возникала структура container/presentational: компонент-контейнер, реализованный классом, состоял из логики состояния и побочных эффектов и передавал данные в виде пропсов вниз презентационному компоненту, реализованному функцией, который отвечал за внешний вид.

Однако, более вышеуказанный шаблон не требуется, т.к. React представил такую важную фичу, как [React Hooks](https://reactjs.org/docs/hooks-intro.html), которые позволяют в функциональных компонентах использовать состояние и методы жизненного цикла компонента.

_Create React App_

В данном проекте используется инструмент [Create React App](https://create-react-app.dev/). Он помогает быстро создать предварительно подготовленную структуру React-приложения и связать его с [Webpack](https://webpack.js.org/). Webpack - это инструмент, который объединяет JavaScript-код, написанный разработчиком приложения, и JavaScript-код любых внешних библиотек в один пакет, часто называемый бандлом (англ. bundle), представляющий собой либо один файл, либо серию из нескольких файлов. Бандлинг улучшает производительность в продакшене (англ. production): браузер намного быстрее загружает несколько больших связанных файлов, чем очень большое количество небольших. Помимо этого Webpack позволяет скомпилировать ES6+ JavaScript-код в более старый формат, который могут распознать почти все браузеры. Также Webpack может помочь скомпилировать TypeScript-код в JavaScript-код. Большое количество современных приложений используют Webpack. Несмотря на то, что он является мощным инструментом, у него есть своя цена использования: он довольно продвинутый и не очень простой для понимания, чтобы его настроить. В связи с этим и используется Create React App, благодаря которому Webpack уже настроен при инициализации каркаса React-приложения.

### React Router

Маршрутизация - это процесс навигации по веб-приложению с помощью URL-адресов. При нажатии ссылки на веб-странице именяется URL-адрес, который затем переводит пользователя на новую страницу. Маршрутизация полезна, когда приложение начинает разрастаться и становится сложно отображать всю информацию на одной странице. Маршрутизацию в веб-приложении можно реализовать на стороне сервера (англ. server-side routing) или на стороне клиента (англ. client-side routing).

_Маршрутизация на стороне сервера_

При такой маршрутизации навигация по веб-страницам полностью выполняется сервером. Когда пользователь нажимает ссылку, браузер отправляет серверу новый запрос на получение веб-страницы.

Плюсы:

- Клиент запрашивает у сервера только ту веб-страницу, которую просматривает пользователь, а не всё приложение. В результате начальная загрузка страницы часто происходит быстрее, поскольку клиент загружает контент только для одной веб-страницы.

- Поисковая оптимизация (англ. Search Engine Optimization, SEO) оптимизирована для приложений, рендеринг которых происходит на стороне сервера (англ. server-rendered applications).

Минусы:

- Каждое изменение URL-адреса приводит к обновлению всей страницы, которую сервер возвращает клиенту. Когда пользователь переходит от маршрута к маршруту, он видит неприятное мигающее состояние.

- Используемые в приложении шаблоны, которые должны оставаться неизменными (например, верхний и нижний колонтитулы), придётся запрашивать у сервера снова и снова.

_Маршрутизация на стороне клиента_

При данной маршрутизации навигация по веб-страницам полностью обрабатывается JavaScript-кодом, загруженным в браузер. Когда пользователь нажимает на ссылку, браузер просто отображает "новый контент" из кода, загруженного в память. Из-за этого веб-приложение, использующее client-side routing, часто называют одностраничным приложением (англ. Single-Page Application, SPA). Такое приложение состоит только из одной веб-страницы, а разные маршруты в нём представляют одну и ту же страницу, но с разными отображениями контента.

Плюсы:

- Переход между страницами часто выполняется быстрее, чем в приложении, которое отрисовывает сервер, поскольку после начальной загрузки приложения при переходе от маршрута к маршруту нет необходимости ждать ответа сервера с обновлённой страницей.

- Отсутствует белое "мигающее" состояние при переходе от маршрута к маршруту.

Минусы:

- Поскольку шаблон всего веб-приложения должен быть загружен при первом запросе, время начальной загрузки страницы часто больше, чем у приложений, которые отрисовывает сервер.

- Сканирование в поисковых системах менее оптимизировано. В современных браузерах наблюдается некоторый прогресс в сканировании одностраничных приложений для поисковых систем, но он не так эффективен, как веб-сайты с маршрутизацией на стороне сервера.

### Ant Design

Написание надёжного CSS-кода для больших приложений требует много работы, т.к. необходимо учитывать множество вещей: внешний вид, отзывчивость, доступность и структуру. Здесь и приходят на помощь UI/CSS-фреймворки - пакеты, содержащие предварительно написанные, стандартизированные и часто хорошо протестированные шаблоны и CSS-код. Они помогают ускорить разработку, часто предоставляют grid layout и помогают обеспечить хороший веб-дизайн. Однако, у них есть недостатки: они ограничивают возможности по кастомизации и редактированию подготовленных стилей и настроек, увеличивают размер приложения за счёт большего объёма кода и часто требуют много времени, чтобы к ним привыкнуть.

Существуют разные React UI-фреймворки, содержащие большое количество переиспользуемых React-компонентов, которые можно просто импортировать в приложение и использовать напрямую. В данном приложении используется надёжный и невероятно хорошо отлаженный фреймворк [Ant Design](https://ant.design/), содержащий практически все компоненты, которые только могут понадобиться. При этом все компоненты этого фреймворка выглядит красиво.

При использовании Ant Design могут возникнуть некоторые трудности:

- При том, что можно произвести кастомизацию, временами это немного утомительно.
- Размер пакета фреймворка, когда он используется в приложении, довольно велик.
- Есть несколько компонентов, которые не подходят для обеспечения доступности.

Стоит отметить, что фреймворк часто обновляется и разработчики не обходят стороной решение вопросов, связанных с размером пакета и доступностью.

## Функциональные возможности

Описание функциональных возможностей содержится в соответствующей документации к [серверу](./server/README.md) и [клиенту](./client/README.md).

## Как развернуть проект

1. Клонируйте репозиторий:

   `git clone https://github.com/aleksandr-e-lebedev/tinyhouse.git`

2. Для установки необходимых пакетов выполните:

   `npm install`

3. В директориях `./server` и `./client` создайте по конфигурационному файлу `.env`, указав в каждом переменные окружения в соответствии со следующим синтаксисом: на каждой новой строке - `NAME=VALUE`, где `NAME` - это имя переменной, а `VALUE` - её значение.

   ```
   Переменные окружения для сервера:

     1. NODE_ENV
     2. PORT
     3. PUBLIC_URL
     4. DB_URL

     5. JWT_SECRET
     6. JWT_DURATION
     7. JWT_COOKIE_DURATION

     8. GOOGLE_CLIENT_ID
     9. GOOGLE_CLIENT_SECRET

     10. GOOGLE_GEOCODING_API_KEY

     11. STRIPE_CLIENT_ID
     12. STRIPE_API_SECRET

     13. CLOUDINARY_URL


   Переменные окружения для клиента:

     1. REACT_APP_STRIPE_PUBLISHABLE_KEY

   ```

4. В зависимости от того в каком режиме запущено приложение: разработка или продакшен, присвойте переменной окружения `NODE_ENV` значение `development` или `production` соответственно. При развёртывании приложения на Heroku, для данной переменной платформа сама установит значение `production`.

5. Для режима `development` присвойте переменной окружения `PORT` значение `9000`, а переменной `PUBLIC_URL` - `http://localhost:3000`. При развёртывании приложения на Heroku, платформа сама назначит переменной `PORT` свободный порт. В продакшене переменной `PUBLIC_URL` присвойте выделенный под приложение домен.

6. Для использования MongoDB создайте учётную запись по адресу [https://www.mongodb.com](https://www.mongodb.com/). Затем создайте кластер и пользователя для взаимодействия с базой данной в этом кластере. Находясь в кластере, нажмите кнопку "Connect", после чего откроется модальное окно, в котором необходимо выбрать "Connect your application", далее выбрать версию драйвера для Node.js и скопировать connection URL в переменную окружения `DB_URL`, заменив "password" паролем для созданного пользователя, а "myFirstDatabase" - именем созданной базы данных.

7. Поскольку для авторизации на сервере используется токен доступа, созданный по стандарту [JSON Web Token](https://datatracker.ietf.org/doc/html/rfc7519) ([JWT](https://ru.wikipedia.org/wiki/JSON_Web_Token)), то в режиме `production` в переменной окружения `JWT_SECRET` необходимо указать секретный ключ, который будет использован для создания подписи выдаваемого приложением токена доступа, отличный от секретного ключа в режиме `development`.

   Вы можете создать криптостойкий псевдослучайный `JWT_SECRET` для режима `production`, выполнив:

   ```
    node -e "console.log(require('crypto').randomBytes(32).toString('hex'));"
   ```

   По умолчанию сервер устанавливает для токена доступа и cookie, в которых он передаётся, срок 7 дней, однако с помощью переменных окружения `JWT_DURATION` и `JWT_COOKIE_DURATION` можно установить другой срок действия.

8. Для использования Google OAuth [создайте учётные данные для авторизации](<(https://developers.google.com/identity/sign-in/web/sign-in#create_authorization_credentials)>), идентифицирующие приложение на сервере OAuth 2.0 Google. В качестве таких учётных данных используйте идентификатор клиента OAuth (англ. OAuth Client ID), который позволяет приложению запрашивать согласие пользователя на доступ к Google API от его имени с целью получения доступа к его данным.

   После завершения настройки присвойте:

   - переменной окружения `GOOGLE_CLIENT_ID` созданный идентификатор клиента (англ. Client ID);
   - переменной окружения `GOOGLE_CLIENT_SECRET` созданный секрет клиента (англ. Client Secret).

   Поскольку приложение взаимодействует с Google People API, перейдите в консоль разработчиков Google проекта, найдите People API в библиотеке API и включите его.

9. Для включения Google's Geocoding API, необходимо его активировать из консоли разработчика Google ([Google Developer Console](https://console.cloud.google.com)). Доступ к разделу API можно получить по адресу [https://console.cloud.google.com/apis](https://console.cloud.google.com/apis). Необходимо создать API key и присвоить значение переменной окружения `GOOGLE_GEOCODING_API_KEY`.

10. Для подключения TinyHouse к Stripe необходимо создать учётную запись в Stripe. Это можно сделать по адресу [https://dashboard.stripe.com/register](https://dashboard.stripe.com/register), где требуется заполнить необходимую информацию и нажать "Create account". В панели управления учётной записи необходимо найти публикуемый (англ. publishable) и секретный (англ. secret) ключи и сохранить их значения в переменные окружения `REACT_APP_STRIPE_PUBLISHABLE_KEY` и `STRIPE_API_SECRET` соответственно. Также необходимо найти идентификатор клиента (англ. client ID) и присвоить значение переменной `STRIPE_CLIENT_ID`.

11. Для использования облачного сервиса для изображений Cloudinary необходимо создать учётную запись на веб-сайте [https://cloudinary.com](https://cloudinary.com/), зайти в панель управления, найти в разделе "Account Details" в поле "API Environment variable" переменную окружения `CLOUDINARY_URL` и сохранить её в конфигурационном файле `.env` в директории `./server`.

12. Для запуска GraphQL Playground в режиме `development` необходимо в браузере перейти по адресу <http://localhost:9000/api>.

### Доступные скрипты

Находясь в корневой директории проекта, вы можете:

1. Установить зависимости для сервера и клиента:

   `npm run install`

2. Запустить сервер в режиме `development` (с hot reload):

   `npm run server`

   Адрес сервера - <http://localhost:9000/api>.

3. Запустить клиент в режиме `development` (с hot reload):

   `npm run client`

   Для просмотра в браузере перейдите по адресу <http://localhost:3000>.

   Если вы сделаете какие-либо изменения в коде, страница будет перезагружена.

4. Собирает и серверную, и клиентускую части приложения для `production`:

   `npm run build`

5. Запускает собранный билд для сервера в режиме `production`:

   `npm run start`

### Дополнительные скрипты

Находясь в директории `server`, вы можете:

1. Запустить [ESLint](https://eslint.org/):

   `npm run lint`

2. Загрузить в базу данных MongoDB моковые данные:

   `npm run seed`

3. Удалить из базы данных MongoDB моковые данные:

   `npm run clear`

Находясь в директории `client`, вы можете:

1. «Извлечь» конфигурацию, если вас не устраивает инструмент сборки и варианты конфигурации:

   `npm run eject`

   Скрипт скопирует все файлы конфигурации, а также такие зависимости, как webpack, Babel, ESLint и т.д., прямо в ваш проект, чтобы вы имели полный контроль над ними.

   Примечание: операцию `eject` нельзя отменить!

2. Запустить [ESLint](https://eslint.org/):

   `npm run lint`

3. Сгенерировать схему GraphQL API:

   `npm run codegen:schema`

   Перед запуском скрипта убедитесь, что у вас запущен сервер. Скрипт скачает схему из GraphQL API, которая нужна для режима разработки, чтобы генерировать TypeScript-типы на её основе.

4. Сгенерировать TypeScript-типы на основе GraphQL-схемы:

   `npm run codegen:generate`

   Перед запуском скрипта убедитесь, что вы сначала сгенерировали схему GraphQL API. Скрипт на основе этой схемы создаст TypeScript-типы, необходимые при разработке приложения.
