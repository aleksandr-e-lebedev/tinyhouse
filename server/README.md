# TinyHouse Server

Данная документация содержит описание функциональных возможностей серверной части приложения TinyHouse. Информация о том, что из себя представляет проект TinyHouse, какие в нём использованы технологии, краткое их описание, а также о том, как развернуть проект, находится в [общей документации](./../README.md) проекта.

Сервер - это [Node](https://nodejs.org/)/[Express](http://expressjs.com/)-сервер, написанный на [TypeScript](https://www.typescriptlang.org/), в обязанности которого входит обслуживание [GraphQL](https://graphql.org/) API и взаимодействие с базой данных [MongoDB](https://www.mongodb.com/), размещённой в кластере [MongoDB Atlas](https://www.mongodb.com/cloud/atlas) для получения или сохранения данных.

## База данных MongoDB

MongoDB - нереляционная база данных, для которой не требуется связанная с ней предопределённая схема для данных. Однако, с помощью TypeScript определена форма данных, которые можно сохранить и получить из БД.

В MongoDB [связанные объекты, т.е. документы, хранятся в коллекциях](https://docs.mongodb.com/manual/core/databases-and-collections/). Таким образом, база данных MongoDB - это просто группа коллекций.

В TinyHouse база данных MongoDB состоит их трёх коллекций документов:

1. Коллекция пользователей (англ. "users" collection): для хранения информации о пользователях приложения.
2. Коллеция объявлений (англ. "listings" collection): для хранения информации об объявлениях, созданных пользователями приложения.
3. Коллекция бронирований (англ. "bookings" collection): для хранения информации о бронированиях, сделанных пользователями приложения.

В целях разработки сервер предоставляет возможность как заполнить базу данных MongoDB фиктивными данными, так и очистить её от них.

## Взаимодействие со сторонними API

Сервер взаимодействует со сторонними API: Google API (Geocoding API и People API), Cloudinary, Stripe.

## Функциональные возможности

### 1. Регистрация и авторизация пользователя с помощью [Google OAuth](https://developers.google.com/identity/sign-in/web/backend-auth)

[OAuth](https://ru.wikipedia.org/wiki/OAuth) - это открытый протокол авторизации, который позволяет предоставить приложениям ограниченный доступ к учётным записям пользователей, созданным на разных платформах, таких как Google, Facebook, Twitter и др., без необходимости передавать им (приложениям) логин и пароль.

Возможность авторизации с помощью такого подхода имеет несколько важных преимуществ:

- В случае взлома приложения пароль от аккаунта (например, Google) останется в безопасности, потому что OAuth не передает пароли, а вместе этого использует токены авторизации для подтверждения личности.
- OAuth позволяет использовать другие платформы, на которых пользователи, скорее всего, уже создали учётные записи, что помогает избежать необходимости создавать новую учётную запись для использования определённого приложения.

Для доступа к Google API приложение использует библиотеку [Google APIs Node.js Client](https://github.com/googleapis/google-api-nodejs-client), официально поддерживаемую Google, которая обеспечивает авторизацию и аутентификацию с помощью OAuth 2.0 и предоставляет возможность Node-приложению взаимодействовать с полным списком Google's API.

Сервер взаимодействует с Google's [People API](https://developers.google.com/people) для получения информации о пользователе, который авторизуется в приложении TinyHouse с помощью своей учётной записи в Google.

Взаимодействие с MongoDB:

- Если пользователь впервые авторизуетися в приложении TinyHouse, в коллекцию "users" базы данных MongoDB вставляется новый документ.
- Если пользователь ранее уже авторизовывался в приложении, т.е. в коллекции "users" уже существует документ пользователя, то сервер просто обновляет информацию в этом документе.

В заголовках ответа среди прочего клиент получит cookie, содержащие токен доступа к ресурсам сервера, созданный по стандарту [JSON Web Token](https://datatracker.ietf.org/doc/html/rfc7519) ([JWT](https://ru.wikipedia.org/wiki/JSON_Web_Token)).

Сервер отправляет клиенту cookie со следующими опциями:

- Установлен флаг "httpOnly", чтобы cookie не были доступны JavaScript-коду на стороне клиента. Это помогает противодействовать [XSS](https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting)-атакам (англ. [Cross-Site Scripting](https://en.wikipedia.org/wiki/Cross-site_scripting) - «межсайтовый скриптинг»).
- Установлен флаг "sameSite", чтобы cookie не были отправлены с межсайтовыми запросами. Данная опция указывает, что cookie могут быть отправлены только с сайта, который пользователь просматривает в настоящее время. Эта возможность доступна в большинстве современных браузеров и помогает предотвратить [CSRF](https://developer.mozilla.org/en-US/docs/Glossary/CSRF)-атаки (англ. [Cross-Site Request Forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery) - "межсайтовая подделка запроса").
- Установлен флаг "secure", который гарантирует, что cookie пересылаются только по защищённому [HTTPS](https://ru.wikipedia.org/wiki/HTTPS)-соединению. Данная опция активироана только для режима `production`.

По умолчанию сервер устанавливает для cookie и токена доступа срок 7 дней, однако с помощью переменных окружения "JWT_COOKIE_DURATION" и "JWT_DURATION" можно установить другой срок действия.

Когда пользователь выходит из системы, сервер очищает cookie.

Для предотвращение CSRF сервер также использует X-CSRF Token. Каждый раз, когда пользователь авторизуется в приложении, сервер генерирует криптостойкую псевдослучайную последовательность байт фиксированной длины (16 байт), приведённую к шестнадцатеричной строке. Эту случайным образом созданную строку сервер отправляет клиенту и использует в качестве токена сеанса. В конечном итоге клиент будет использовать этот токен при каждом запросе к серверу. Сервер использует токен для проверки того, что запрос исходит от действительного пользователя приложения.

### 2. Предоставление информации о пользователе

Доступная для предоставления информация о пользователе отображена в GraphQL Playground.

Пагинация - это процесс разделения большого списка данных на более мелкие дискретные части (или страницы). Используется для уменьшения задержки загрузки данных, поскольку клиенту не нужно ждать загрузки всех данных сразу, вместо этого сервер предоставляет данные небольшими порциями за раз.

Существуют два популярных способа реализации пагинации:

1.  Пагинация на основе смещения (или нумерованных страниц) (англ. Offset-based pagination)

    Клиент передаёт серверу два параметра:

    1. limit (предел) - описывает, сколько объектов данных отображать на странице;
    2. page (страница) - описывает номер страницы, которую пользователь хочет просмотреть.

    Данная пагинация часто является самой простой для реализации, поскольку сервер просто извлекает значения для limit и page и определяет предел контента, отображаемого для определённой страницы.

    Несмотря на простоту реализации, такая пагинация имеет определённый недостаток. Если элементы вставляются или удаляются, когда пользователь просматривает страницы, то есть большая вероятность увидеть один и тот же элемент дважды или пропустить дополнительный элемент. Например, для социальных сетей такой вид пагинации не будет идеальным выбором.

2.  Пагинация на основе курсора (англ. Cursor-based pagination)

    При такой пагинации для отслеживания данных в наборе элементов используется "курсор", который может быть просто ссылкой на идентификатор последнего извлечённого объекта. С точки зрения клиента, курсор просто передаётся, и сервер определяет набор данных, которые должны быть возвращены этим курсором. Поскольку этот курсор более точен, он помогает избежать недостатков, которые можно наблюдать при пагинации на основе смещения, когда пользователь переходит от страницы к странице и элементы добавляются или удаляются.

    Информация о различных типах пагинации в GraphQL содержится в [документации](https://www.apollographql.com/docs/react/pagination/overview/) к библиотеке Apollo Client.

В данном приложении выбрана пагинация на основе смещения, т.к. её довольно просто реализовать с помощью MongoDB (см. [пример реализации](https://docs.mongodb.com/manual/reference/method/cursor.skip/#pagination-example) на сайте документации MongoDB). Используется для предоставления информации:

- об осуществлённых пользователем бронированиях;
- о созданных пользователем объявлениях.

### 3. Создание объявления

Данные, которые необходимо передать серверу для создания объявления, а также данные, возвращаемые сервером при успешном создании объявления, отображены в GraphQL Playground.

### 4. Предоставление информации об объявлении

Данные об объявлении, предоставляемые сервером, отображены в GraphQL Playground.

### 5. Предоставление информации о множественных объявлениях

Данные, которые необходимо передать серверу для получения информации, а также содержание ответа от сервера см. в GraphQL Playground.

Запрашиваемый список объявления можно отсортировать по цене: от самой низкой до самой высокой и наоборот. Для списка объявлений реализована пагинация.

### 6. Обработка поисковых запросов, основанных на местоположении, с помощью [Google's Geocode](https://developers.google.com/maps/documentation/geocoding/overview)

Геокодирование (англ. geocoding) - это процесс преобразования адресной информации в виде текста в конкретные географические координаты.

В приложении возможность геокодирования адресной информации используется для того, чтобы пользователи могли искать объявления в определённых местах. Геокодирование реализовано с помощью [Google's Geocoding API](https://developers.google.com/maps/documentation/geocoding/overview).

Возможность клиента запросить у сервера список документов, соответствующих объявлениям, для разных мест - это замечательно. Если в базе данных хранится небольшое количество таких документов, то она довольно быстро возвращает результаты. Однако, если в базе данных содержатся десятки миллионов объявлений, то, при попытке выполнить поиск по всем объявлениям, например, в Нью-Йорке, серверу потребуется несколько минут, чтобы просмотреть всю коллекцию и выбрать правильные данные. Здесь на помощь приходят индексы базы данных MongoDB (англ. [MongoDB Indexes](https://docs.mongodb.com/manual/indexes/)).

**MongoDB Indexes**

MongoDB-индексы поддерживают эффективное выполнение запросов в коллекции. Без индексов MongoDB должна выполнить сканирование коллекции (т.е. каждого документа в коллекции), чтобы выбрать документы, сооответствующие запросу. Если для запроса существует соответствующий индекс, MongoDB может использовать этот индекс, чтобы ограничить количество документов, которые необходимо проверить.

Индексы важны, когда дело доходит до баз данных. Индексы представляют собой структуры данных, которые, по сути, обеспечивают более быстрый доступ к данным. Без индекса MongoDB будет сканировать каждый документ в коллекции, чтобы удовлетворить запрос. Если есть миллионы документов, то MongoDB пройдёт по каждому документу.

Когда мы определяем индекс для определенного поля, мы говорим базе данных (в данном случае MongoDB) создать другую структуру данных для значений этого поля для каждого документа в коллекции. Когда мы предоставляем запрос на поиск документов на основе определенных значений поля, MongoDB не выполняет сканирование коллекции и не просматривает каждый документ, а вместе этого получает документы, которые мы ищем, более эффективным по времени способом. Как? Это связано с тем, что по структуре данных, которую MongoDB готовит для значений поля в индексе, теперь перемещаться легче.

В документации MongoDB говорится, что для индексов используется структура данных B-tree. [B-tree](https://en.wikipedia.org/wiki/B-tree) - это самобалансирующаяся древовидная структура данных, которая поддерживает отсортированные данные и позволяет довольно быстро выполнять поиск, последовательный доступ, вставку и удаление данных.

> Обход структуры данных B-Tree зачастую выполненяется за логарифмическое время O(log N), что более эффективно по времени при увеличении размера данных по сравнению с линейным временем O(N), за которое выполняется сканирование всей коллекции.

Ключевой вывод: указание индексов помогает сократить время, необходимое для запроса документов в больших коллекциях.

MongoDB определяет индексы на уровне коллекции и поддерживает их для любого поля или подполя документов в коллекции.

MongoDB также поддерживает создание индексов для нескольких полей, также известных как составные индексы (англ. [compound indexes](https://docs.mongodb.com/manual/core/index-compound/)).

Когда дело доходит до поиска объявлений в каком-либо месте, запрашиваются три поля: country, admin, city. Как минимум, запрос должен содержать страну. Если запрос включает все три поля, то MongoDB осуществляет поиск документов, удовлетворяющих не одному полю, а трём.

Чтобы подготовить индексы для трёх полей, которые запрашивает клиент, когда дело доходит до получения информации об объявлениях, необходимо зайти в панель управлеиня Atlas для кластера MongoDB и создать составной индекс:

```ts
  {
    country: 1,
    admin: 1,
    city: 1
  }
```

Вышеуказанный составной индекс сортирует документы с объявлениями сначала по стране, затем по административному району и, наконец, по городу. Значение "1" для каждого поля помогает подготовить отсортированные индексы в возрастающем алфавитном порядке.

Если бы база данных содержала миллионы объявлений, то запрос, использующий созданный составной индекс для поиска на основе местоположения, потенциально мог бы занять секунды, а не минуты.

### 7. Хранение изображений с помощью [Cloudinary](https://cloudinary.com/)

Когда пользователь приложения TinyHouse создаёт объявление, клиент, помимо прочего, передаёт серверу изображение, которое закодировано в формате Base64, т.е. представляет собой строку.

Нет ничего плохого в том, чтобы хранить изображения в формате [Base64](https://developer.mozilla.org/en-US/docs/Glossary/Base64) в базе данных, но такой подход не идеален. У него есть два недостатка:

1.  Изображения могут занимать много места в базе данных. Файлы изображений по своей природе имеют большой размер. Кроме того, кодирование файла изображения в строку Base64 фактически [увеличивает размер исходного изображения примерно на 33%](https://developer.mozilla.org/en-US/docs/Glossary/Base64#encoded_size_increase). В документе, соответствующем созданному объявлению, поле для изображения занимает больше места, чем остальные поля вместе взятые.
2.  Если для всех объявлений хранить в базе данных изображения в формате Base64, то передача клиенту данных всех изображений через GraphQL API просто замедлит время ответа. В итоге, приложение может стать медленным и неоптимизированным.

Здесь на помощь приходит облачный сервис управления изображениями и видео. Такой сервис хранит изображения в облаке, и всё, что нужно сделать, это сохранить URL изображения в базе данных вместо самого изображения. Если бы приложение TinyHouse использовало видео, то подобный сервис также мог бы помочь хранить и видео.

Облачные сервисы управления изображениями решают две вышеуказанные проблемы:

1.  Больше не нужно хранить изображения непосредственно в базе данных, так как теперь необходимо хранить только URL изображений. Это уменьшает размер базы данных, что увеличивает скорость некоторых операций с ней, таких как копирование, чтение, резервное копирование и т.д. Не говоря уже о том, что это может сэкономить деньги, поскольку память базы данных стоит денег.
2.  Приложение становится намного более отзывчивым, потому что нет необходимости передавать клиенту изображение в формате Base64. Клиент будет получать только URL изображения. При этом отдельные изображения на стороне клиента, при передаче их URL в HTML-теги "img", будут загружаться по разным URL параллельно.

Ещё одно важное преимущество, которое в приложении TinyHouse не используется, но оно невероятно полезно, заключается в том, что облачные сервисы изображений часто позволяют управлять изображениями и улучшать их с помощью API на основе URL. С помощью популярных облачных решений можно выполнить практически любые манипуляции с изображениями, такие как изменение размера, добавление фильтров, вращение, округление углов и многие другие.

**Cloudinary**

Хотя существует множество различных облачных решений, одним из наиболее популярных является Cloudinary. У Cloudinary есть бесплатный тарифный план, который позволяет хранить около 25 Гб изображений, что идеально подходит для тестирования при разработке TinyHouse.

Для взаимодействия с Cloudinary API в приложении используется библиотека [Cloudinary для Node.js](https://github.com/cloudinary/cloudinary_npm).

На веб-сайте сервиса предоставлена подробная [документация](https://cloudinary.com/documentation/image_upload_api_reference) по использованию API, в том числе и по загрузке изображений.

### 8. Бронирование объявления на определённый период времени

При бронировании объявления на сервере выполняется проверка соблюдения следуюших условий:

1.  пользователь, желающий осуществить бронирование, должен быть авторизован;
2.  объявление, которое необходимо забронировать, должно существать в базе данных;
3.  арендодатель не пытается забронировать собственное объявление;
4.  арендодатель для этого объявления должен существать в базе данных и быть подключён к Stripe;
5.  дата заезда и дата выезда не могут быть позже, чем через 30 дней от текущей даты;
6.  дата выезда не может быть раньше даты заезда.

### 9. Обработка платежа с помощью [Stripe](https://stripe.com/)

Stripe - это сторонний платежный процессор, который помогает приложениям и бизнесам безопасно/надёжно принимать платежи в Интернете. Приложение TinyHouse использует Stripe для обработки платежей между арендаторами и арендодателями.

Бизнес-модель платформы TinyHouse - это онлайн-торговая площадка, где пользователи могут размещать и бронировать объявления об аренде. При бронировании пользователь, совершающий бронирование (т.е. арендатор), должен заплатить владельцу объявления (т.е. арендодателю) денежную сумму. TinyHouse принимает процент от этой транзакции в качестве дохода (также известный как комиссия платформы).

Создание и интегрирование платёжной инфраструктуры поверх приложения является чрезвычайно сложной задачей. Хотим ли мы, чтобы наши пользователи могли платить дебетовой картой? Что ж, нам в значительной степени необходимо работать с каждым банком в стране, в которой будет работать наша платформа. Хотим ли мы, чтобы наши пользователи могли платить кредитной картой? Опять же, нам нужно будет работать с инструментами, предоставленными нам компаниями, выпускающими кредитные карты, которы мы хотели бы поддерживать (Visa, Mastercard и т.д.). Хотим ли мы принимать международные платежи? Выход на международный уровень - это ещё одна проблема.

Если бы нам пришлось пройти через подход к созданию нашей собственной инфраструктуры пользовательских платежей, нам нужно было бы работать со всеми этими различными сторонами. Это займёт очень много времени и, вероятно, сложнее, чем собственно приложение TinyHouse, которое создаётся. Не говоря уже о том, что в зависимости от того, где работает приложение, существуют строгие законы и правила в отношении услуг, связанных с переводом денег.

Здесь на помощь приходит сторонний платёжный процессор. Такие компании, как [Stripe](https://stripe.com/) и [PayPal](https://www.paypal.com/ru/home), специализируются на платежах. Для упрощения платежей в приложении TinyHouse используется Stripe.

**Stripe**

Stripe - это технологическая компания, которая помогает создавать инфраструктуру, в которой онлайн-компании, такие как TinyHouse, могут принимать платежи в Интернете. Stripe устраняет сложность работы с финансами и платежами, работая с различными финансовыми учреждениями, регулирующими органами, платёжными сетями и банками, поэтому компаниям, подобным TinyHouse, не приходится заниматься этим самим.

Довольно большое количество компаний используют Stripe: миллионы и более чем в 120 странах. Сюда входят небольшие компании, а также организации с оборотом от миллиона до миллиарда долларов, такие как [Amazon](https://www.amazon.com/), [Google](https://www.google.com/), [Shopify](https://www.shopify.com/), [Microsoft](https://www.microsoft.com/ru-ru) и т.д.

> Примечание: Чтобы узнать больше о Stripe как о компании, обязательно ознакомьтесь с разделом about документации Stripe - [https://stripe.com/about](https://stripe.com/about).

Stripe взимает определённый процент за каждую успешную оплату с помощью карты, который зависит от тарифного плана.

> Примечание: Сведения о ценах на Stripe содержатся в документации - [https://stripe.com/pricing](https://stripe.com/pricing).

**Stripe Connect**

Среди множества различных инструментов, которые предоставляет Stripe, для приложения TinyHouse используется один под названием [Stripe Connect](https://stripe.com/connect).

Stripe Connect - это решение, предназначенное для торговых площадок и платформ, посольку оно позволяет приложениям принимать платежи и осуществлять выплаты третьим лицам. Stripe Connect поддерживает множество различных бизнес-моделей, таких как электронная коммерция, краудфандинг и т.д.

Stripe Connect предоставляет множество различных настроек того, как мы хотим, чтобы платежи направлялись в приложении. В TinyHouse используется один из наиболее простых сценариев - модель отношений один-к-одному (англ. one-to-one). Соглано этой модели, в приложении TinyHouse есть один клиент (т.е. арендатор), который платит одному получателю (т.е арендодателю). TinyHouse использует Stripe Connect, чтобы арендодатель платил приложению небольшой процент за использование приложения и получения платежей от арендаторов.

Для взаимодействия сервера с платформой Stripe используется библиотека [Stripe Node.js Library](https://github.com/stripe/stripe-node).
